#!/usr/bin/env python3
"""
Static Malware Analyzer
Performs static analysis on suspicious files without execution.

Repository: https://github.com/Masriyan/Claude-Code-CyberSecurity-Skill
"""

import argparse
import hashlib
import json
import logging
import math
import os
import re
import sys
import time
from collections import Counter
from typing import Any, Dict, List

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)

SUSPICIOUS_STRINGS = [
    "cmd.exe", "powershell", "wscript", "cscript", "mshta",
    "rundll32", "regsvr32", "certutil", "bitsadmin",
    "CreateRemoteThread", "VirtualAllocEx", "WriteProcessMemory",
    "NtUnmapViewOfSection", "SetWindowsHookEx", "GetAsyncKeyState",
    "IsDebuggerPresent", "CheckRemoteDebuggerPresent",
    "URLDownloadToFile", "InternetOpenUrl", "HttpSendRequest",
    "WinExec", "ShellExecute", "CreateProcess",
    "RegSetValueEx", "CreateService",
    "\\AppData\\", "\\Temp\\", "\\System32\\",
    "HKEY_LOCAL_MACHINE", "HKEY_CURRENT_USER",
    "password", "encrypt", "decrypt", "backdoor", "keylog",
    "bitcoin", "wallet", "ransom", "mutex",
]

SUSPICIOUS_IMPORTS = {
    "process_injection": [
        "CreateRemoteThread", "VirtualAllocEx", "WriteProcessMemory",
        "NtMapViewOfSection", "NtUnmapViewOfSection", "QueueUserAPC",
    ],
    "persistence": [
        "RegSetValueExA", "RegSetValueExW", "CreateServiceA",
        "CreateServiceW", "WriteFile", "CopyFileA",
    ],
    "anti_debug": [
        "IsDebuggerPresent", "CheckRemoteDebuggerPresent",
        "NtQueryInformationProcess", "GetTickCount",
        "QueryPerformanceCounter", "OutputDebugStringA",
    ],
    "network": [
        "InternetOpenA", "InternetOpenUrlA", "HttpSendRequestA",
        "URLDownloadToFileA", "WSAStartup", "connect", "send", "recv",
    ],
    "crypto": [
        "CryptEncrypt", "CryptDecrypt", "CryptHashData",
        "CryptAcquireContextA", "CryptCreateHash",
    ],
    "keylogging": [
        "SetWindowsHookExA", "GetAsyncKeyState", "GetKeyState",
        "GetForegroundWindow", "GetWindowTextA",
    ],
}


class StaticAnalyzer:
    """Static malware analysis engine."""

    def __init__(self, filepath: str):
        self.filepath = filepath
        self.filesize = os.path.getsize(filepath)
        with open(filepath, "rb") as f:
            self.data = f.read()

    def calculate_hashes(self) -> Dict[str, str]:
        """Calculate multiple hash types."""
        return {
            "md5": hashlib.md5(self.data).hexdigest(),
            "sha1": hashlib.sha1(self.data).hexdigest(),
            "sha256": hashlib.sha256(self.data).hexdigest(),
            "sha512": hashlib.sha512(self.data).hexdigest(),
        }

    def identify_file_type(self) -> Dict[str, str]:
        """Identify file type from magic bytes."""
        magic_bytes = {
            b"\x4d\x5a": "PE (Windows Executable)",
            b"\x7f\x45\x4c\x46": "ELF (Linux Executable)",
            b"\xfe\xed\xfa\xce": "Mach-O (macOS 32-bit)",
            b"\xfe\xed\xfa\xcf": "Mach-O (macOS 64-bit)",
            b"\x50\x4b\x03\x04": "ZIP Archive (or Office/JAR/APK)",
            b"\x25\x50\x44\x46": "PDF Document",
            b"\xd0\xcf\x11\xe0": "OLE2 (MS Office Legacy)",
            b"\x52\x61\x72\x21": "RAR Archive",
            b"\x1f\x8b\x08": "GZIP Archive",
        }

        for magic, ftype in magic_bytes.items():
            if self.data[:len(magic)] == magic:
                return {"type": ftype, "magic_hex": magic.hex()}

        return {"type": "Unknown", "magic_hex": self.data[:4].hex()}

    def calculate_entropy(self) -> Dict[str, Any]:
        """Calculate overall and section-level entropy."""
        overall = self._shannon_entropy(self.data)
        return {
            "overall": round(overall, 4),
            "is_packed": overall > 6.8,
            "is_encrypted": overall > 7.5,
            "assessment": self._entropy_assessment(overall),
        }

    def _shannon_entropy(self, data: bytes) -> float:
        if not data:
            return 0.0
        counts = Counter(data)
        length = len(data)
        return -sum((c / length) * math.log2(c / length) for c in counts.values() if c > 0)

    def _entropy_assessment(self, entropy: float) -> str:
        if entropy > 7.5:
            return "Very high entropy — likely encrypted or compressed"
        elif entropy > 6.8:
            return "High entropy — likely packed (UPX, Themida, etc.)"
        elif entropy > 5.0:
            return "Moderate entropy — normal compiled binary"
        else:
            return "Low entropy — text-heavy or sparse data"

    def extract_strings(self, min_length: int = 4) -> Dict[str, Any]:
        """Extract and categorize strings."""
        ascii_pattern = re.compile(rb"[\x20-\x7e]{%d,}" % min_length)
        unicode_pattern = re.compile(rb"(?:[\x20-\x7e]\x00){%d,}" % min_length)

        ascii_strings = [m.group().decode("ascii") for m in ascii_pattern.finditer(self.data)]
        unicode_strings = [m.group().decode("utf-16-le", errors="ignore") for m in unicode_pattern.finditer(self.data)]

        all_strings = list(set(ascii_strings + unicode_strings))

        urls = [s for s in all_strings if re.match(r"https?://", s)]
        ips = [s for s in all_strings if re.match(r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}", s)]
        emails = [s for s in all_strings if re.match(r"[^@]+@[^@]+\.[^@]+", s)]
        paths = [s for s in all_strings if re.match(r"[A-Z]:\\", s) or s.startswith("/")]
        registry = [s for s in all_strings if s.startswith(("HKEY_", "HKLM", "HKCU"))]
        suspicious = [s for s in all_strings if any(ss.lower() in s.lower() for ss in SUSPICIOUS_STRINGS)]

        return {
            "total_count": len(all_strings),
            "urls": urls[:30],
            "ip_addresses": ips[:20],
            "email_addresses": emails[:10],
            "file_paths": paths[:30],
            "registry_keys": registry[:20],
            "suspicious": suspicious[:50],
        }

    def detect_packing(self) -> Dict[str, Any]:
        """Detect known packers and protectors."""
        indicators = []

        packer_signatures = {
            b"UPX!": "UPX",
            b"UPX0": "UPX",
            b"UPX1": "UPX",
            b".aspack": "ASPack",
            b"PEC2": "PECompact",
            b".themida": "Themida",
            b".vmp0": "VMProtect",
            b".vmp1": "VMProtect",
            b"MPRESS1": "MPRESS",
            b"nsp0": "NsPack",
        }

        for signature, packer in packer_signatures.items():
            if signature in self.data:
                indicators.append({"packer": packer, "signature": signature.decode("ascii", errors="replace")})

        entropy = self._shannon_entropy(self.data)
        low_import_count = self.data.count(b"\x00" * 16) > (self.filesize // 100)

        return {
            "packers_detected": indicators,
            "high_entropy": entropy > 6.8,
            "likely_packed": len(indicators) > 0 or entropy > 6.8,
        }

    def generate_iocs(self) -> Dict[str, Any]:
        """Generate Indicators of Compromise."""
        hashes = self.calculate_hashes()
        strings = self.extract_strings()

        return {
            "file_hashes": hashes,
            "file_size": self.filesize,
            "network_indicators": {
                "urls": strings["urls"],
                "ip_addresses": strings["ip_addresses"],
                "domains": list(set(
                    re.findall(r"[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}", " ".join(strings.get("urls", [])))
                )),
            },
            "host_indicators": {
                "file_paths": strings["file_paths"],
                "registry_keys": strings["registry_keys"],
            },
        }

    def run(self) -> Dict[str, Any]:
        """Execute full static analysis."""
        logger.info("=" * 60)
        logger.info("Static Malware Analysis: %s", self.filepath)
        logger.info("=" * 60)

        results = {
            "file": os.path.basename(self.filepath),
            "file_size": self.filesize,
            "file_type": self.identify_file_type(),
            "hashes": self.calculate_hashes(),
            "entropy": self.calculate_entropy(),
            "strings": self.extract_strings(),
            "packing": self.detect_packing(),
            "iocs": self.generate_iocs(),
            "timestamp": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        }

        logger.info("File type: %s", results["file_type"]["type"])
        logger.info("SHA-256: %s", results["hashes"]["sha256"])
        logger.info("Entropy: %.4f (%s)", results["entropy"]["overall"], results["entropy"]["assessment"])
        logger.info("Packed: %s", results["packing"]["likely_packed"])
        logger.info("URLs found: %d", len(results["strings"]["urls"]))
        logger.info("Suspicious strings: %d", len(results["strings"]["suspicious"]))

        return results


def main():
    parser = argparse.ArgumentParser(
        description="Static Malware Analyzer",
        epilog="https://github.com/Masriyan/Claude-Code-CyberSecurity-Skill",
    )
    parser.add_argument("--file", "-f", required=True, help="File to analyze")
    parser.add_argument("--output", "-o", help="Output file (JSON)")
    parser.add_argument("--verbose", "-v", action="store_true")
    args = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    if not os.path.exists(args.file):
        logger.error("File not found: %s", args.file)
        sys.exit(1)

    analyzer = StaticAnalyzer(args.file)
    results = analyzer.run()

    if args.output:
        with open(args.output, "w") as f:
            json.dump(results, f, indent=2)
        logger.info("Report saved to %s", args.output)
    else:
        print(json.dumps(results, indent=2))


if __name__ == "__main__":
    main()
