#!/usr/bin/env python3
"""
Configuration Security Auditor
Checks server and application configurations against security best practices.

Repository: https://github.com/Masriyan/Claude-Code-CyberSecurity-Skill
"""

import argparse
import json
import logging
import re
import sys
import time
from typing import Any, Dict, List

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)


NGINX_CHECKS = [
    {
        "id": "NGINX-001",
        "title": "Server tokens exposed",
        "severity": "MEDIUM",
        "check": lambda c: "server_tokens off" not in c,
        "description": "Server version is exposed in HTTP headers",
        "remediation": "Add 'server_tokens off;' to the http block",
    },
    {
        "id": "NGINX-002",
        "title": "Missing X-Frame-Options header",
        "severity": "MEDIUM",
        "check": lambda c: "X-Frame-Options" not in c,
        "description": "Missing clickjacking protection header",
        "remediation": "Add 'add_header X-Frame-Options \"SAMEORIGIN\";'",
    },
    {
        "id": "NGINX-003",
        "title": "Missing X-Content-Type-Options header",
        "severity": "LOW",
        "check": lambda c: "X-Content-Type-Options" not in c,
        "description": "Missing MIME-type sniffing protection",
        "remediation": "Add 'add_header X-Content-Type-Options \"nosniff\";'",
    },
    {
        "id": "NGINX-004",
        "title": "Missing Content-Security-Policy header",
        "severity": "HIGH",
        "check": lambda c: "Content-Security-Policy" not in c,
        "description": "No CSP header to prevent XSS and injection attacks",
        "remediation": "Add a Content-Security-Policy header appropriate for your application",
    },
    {
        "id": "NGINX-005",
        "title": "SSL/TLS not configured or weak protocols",
        "severity": "HIGH",
        "check": lambda c: "ssl_protocols" in c and ("SSLv3" in c or "TLSv1 " in c or "TLSv1.0" in c),
        "description": "Weak SSL/TLS protocols (SSLv3, TLSv1.0) are enabled",
        "remediation": "Set 'ssl_protocols TLSv1.2 TLSv1.3;'",
    },
    {
        "id": "NGINX-006",
        "title": "Directory listing enabled",
        "severity": "MEDIUM",
        "check": lambda c: "autoindex on" in c,
        "description": "Directory listing allows attackers to browse file structure",
        "remediation": "Remove 'autoindex on;' or set to 'autoindex off;'",
    },
    {
        "id": "NGINX-007",
        "title": "Missing HSTS header",
        "severity": "HIGH",
        "check": lambda c: "Strict-Transport-Security" not in c,
        "description": "No HTTP Strict Transport Security header",
        "remediation": "Add 'add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\";'",
    },
]

SSHD_CHECKS = [
    {
        "id": "SSH-001",
        "title": "Root login permitted",
        "severity": "CRITICAL",
        "check": lambda c: re.search(r"PermitRootLogin\s+yes", c) is not None,
        "description": "Direct root login via SSH is allowed",
        "remediation": "Set 'PermitRootLogin no' or 'PermitRootLogin prohibit-password'",
    },
    {
        "id": "SSH-002",
        "title": "Password authentication enabled",
        "severity": "HIGH",
        "check": lambda c: re.search(r"PasswordAuthentication\s+yes", c) is not None or "PasswordAuthentication" not in c,
        "description": "Password-based SSH authentication is enabled (vulnerable to brute force)",
        "remediation": "Set 'PasswordAuthentication no' and use key-based authentication",
    },
    {
        "id": "SSH-003",
        "title": "Empty passwords allowed",
        "severity": "CRITICAL",
        "check": lambda c: re.search(r"PermitEmptyPasswords\s+yes", c) is not None,
        "description": "SSH allows login with empty passwords",
        "remediation": "Set 'PermitEmptyPasswords no'",
    },
    {
        "id": "SSH-004",
        "title": "X11 forwarding enabled",
        "severity": "LOW",
        "check": lambda c: re.search(r"X11Forwarding\s+yes", c) is not None,
        "description": "X11 forwarding may expose the X server to attacks",
        "remediation": "Set 'X11Forwarding no' unless specifically required",
    },
    {
        "id": "SSH-005",
        "title": "Weak max authentication attempts",
        "severity": "MEDIUM",
        "check": lambda c: (m := re.search(r"MaxAuthTries\s+(\d+)", c)) is not None and int(m.group(1)) > 4,
        "description": "High MaxAuthTries allows more brute force attempts per connection",
        "remediation": "Set 'MaxAuthTries 3'",
    },
    {
        "id": "SSH-006",
        "title": "SSH Protocol 1 enabled",
        "severity": "CRITICAL",
        "check": lambda c: re.search(r"Protocol\s+1", c) is not None,
        "description": "SSH Protocol 1 is insecure and deprecated",
        "remediation": "Set 'Protocol 2' or remove the Protocol directive (v2 is default)",
    },
]


class ConfigAuditor:
    """Configuration security auditor for various services."""

    AUDIT_RULES = {
        "nginx": NGINX_CHECKS,
        "sshd": SSHD_CHECKS,
    }

    def __init__(self, config_type: str):
        self.config_type = config_type.lower()
        if self.config_type not in self.AUDIT_RULES:
            raise ValueError(f"Unsupported config type: {config_type}. Supported: {list(self.AUDIT_RULES.keys())}")
        self.checks = self.AUDIT_RULES[self.config_type]

    def audit(self, config_path: str) -> Dict[str, Any]:
        """Run all security checks against the configuration file."""
        logger.info("=" * 60)
        logger.info("Configuration Audit: %s (%s)", config_path, self.config_type)
        logger.info("=" * 60)

        with open(config_path, "r") as f:
            content = f.read()

        findings = []
        for check in self.checks:
            try:
                is_vulnerable = check["check"](content)
                if is_vulnerable:
                    finding = {
                        "id": check["id"],
                        "title": check["title"],
                        "severity": check["severity"],
                        "description": check["description"],
                        "remediation": check["remediation"],
                        "status": "FAIL",
                    }
                    findings.append(finding)
                    logger.warning(
                        "[%s] %s — %s", check["severity"], check["id"], check["title"]
                    )
                else:
                    logger.info("[PASS] %s — %s", check["id"], check["title"])
            except Exception as e:
                logger.debug("[SKIP] %s — Error: %s", check["id"], str(e))

        severity_counts = {}
        for f in findings:
            sev = f["severity"]
            severity_counts[sev] = severity_counts.get(sev, 0) + 1

        results = {
            "config_file": config_path,
            "config_type": self.config_type,
            "total_checks": len(self.checks),
            "total_findings": len(findings),
            "passed": len(self.checks) - len(findings),
            "severity_counts": severity_counts,
            "score": round(((len(self.checks) - len(findings)) / len(self.checks)) * 100, 1),
            "findings": findings,
            "timestamp": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        }

        logger.info("=" * 60)
        logger.info("Score: %.1f%% (%d/%d passed)", results["score"], results["passed"], results["total_checks"])
        logger.info("Findings: %d", len(findings))
        logger.info("=" * 60)

        return results


def main():
    parser = argparse.ArgumentParser(
        description="Configuration Security Auditor",
        epilog="https://github.com/Masriyan/Claude-Code-CyberSecurity-Skill",
    )
    parser.add_argument("--type", "-t", required=True, choices=["nginx", "sshd"], help="Configuration type")
    parser.add_argument("--config", "-c", required=True, help="Path to configuration file")
    parser.add_argument("--output", "-o", help="Output file (JSON)")
    parser.add_argument("--verbose", "-v", action="store_true")
    args = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    auditor = ConfigAuditor(args.type)
    results = auditor.audit(args.config)

    if args.output:
        with open(args.output, "w") as f:
            json.dump(results, f, indent=2)
        logger.info("Results saved to %s", args.output)
    else:
        print(json.dumps(results, indent=2))


if __name__ == "__main__":
    main()
